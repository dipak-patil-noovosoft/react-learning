function compareNumbers(e1, e2) {
  return e1 - e2;
}

function compareStrings(e1, e2) {
  return e1.localeCompare(e2);
}
/**
 * isEqual
 * -------
 * Compares two arrays for equality. By default the order is ignored.
 */


function isEqual(a1, a2, compareFunction, ignoreOrder) {
  if (ignoreOrder === void 0) {
    ignoreOrder = true;
  }

  if (a1.length !== a2.length) {
    return false;
  } else {
    // prepare arrays for comparison
    // if ignoreOrder, then we need to copy and sort the arrays
    var arr1 = ignoreOrder ? a1.slice(0).sort(compareFunction) : a1;
    var arr2 = ignoreOrder ? a2.slice(0).sort(compareFunction) : a2; // compare

    var result = true;
    var length = arr1.length;

    for (var i = 0; i < length; i++) {
      if (compareFunction(arr1[i], arr2[i]) !== 0) {
        result = false;
        break;
      }
    }

    return result;
  }
}

var ArrayUtils = {
  compareNumbers: compareNumbers,
  compareStrings: compareStrings,
  isEqual: isEqual
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Returns all keys of a KeySet as an array
 */

var keySetToArray = function keySetToArray(set) {
  return Object.keys(set);
};
/**
 * Returns KeySet as an array of key-value pairs
 */

var keySetToKeyValue = function keySetToKeyValue(set) {
  var keys = Object.keys(set);
  return keys.map(function (key) {
    return {
      key: key,
      value: set[key]
    };
  });
};
/**
 * Comparison function for key-value pairs
 */

function compareKeyBoolValues(e1, e2) {
  var result = e1.key.localeCompare(e2.key);

  if (result !== 0) {
    return result;
  }

  return e1.value === e2.value ? 0 : e1.value ? -1 : 1;
}
/**
 * Returns keys whose value is true
 */

var keySetGetOnKeys = function keySetGetOnKeys(set) {
  var keys = Object.keys(set);
  return keys.filter(function (key) {
    return set[key];
  });
};
/**
 * Returns keys whose value is true
 */

var keySetGetOffKeys = function keySetGetOffKeys(set) {
  var keys = Object.keys(set);
  return keys.filter(function (key) {
    return !set[key];
  });
};
var arrayToKeySet = function arrayToKeySet(keys) {
  return keys.reduce(function (keySet, key) {
    keySet[key] = true;
    return keySet;
  }, {});
};
var mergeKeySets = function mergeKeySets() {
  for (var _len = arguments.length, sets = new Array(_len), _key = 0; _key < _len; _key++) {
    sets[_key] = arguments[_key];
  }

  return Object.assign.apply(Object, [{}].concat(sets));
};
/**
 * Returns true if the two keySets have the same keys (ignoring order)
 * Note that the values are not compared.
 */

var keySetsMatchKeys = function keySetsMatchKeys(k1, k2) {
  var a1 = keySetToArray(k1);
  var a2 = keySetToArray(k2);
  return ArrayUtils.isEqual(a1, a2, ArrayUtils.compareStrings);
};
/**
 * Returns true if the two keySets have the same keys and values (ignoring order)
 * Note that the values are not compared.
 */

var keySetsAreEqual = function keySetsAreEqual(k1, k2) {
  var a1 = keySetToKeyValue(k1);
  var a2 = keySetToKeyValue(k2);
  return ArrayUtils.isEqual(a1, a2, compareKeyBoolValues);
};
/**
 * Returns true if the supplied KeySet contains any of the specified keys
 */

var keySetContainsOneOf = function keySetContainsOneOf(set, keys) {
  // Find a key that exists in the KeySet
  return keys.findIndex(function (key) {
    return set[key];
  }) > -1;
};
/**
 * Returns a new KeySet with values from src copied to target.
 * If a key does not exist in target, then it is not copied.
 * (This is different from Object.assign)
 * Neither src or target are mutated
 */

var keySetCopyValues = function keySetCopyValues(target, src) {
  var srcKeys = keySetToArray(src);

  var targetCopy = _extends({}, target);

  srcKeys.forEach(function (srcKey) {
    if (target[srcKey] !== undefined) {
      targetCopy[srcKey] = src[srcKey];
    }
  });
  return targetCopy;
};

/**
 * Returns an error message from any passed object
 */
var errorToString = function errorToString(error) {
  var result = 'Something went wrong';

  if (error instanceof Error) {
    result = error.message;
  } else if (typeof error === 'string') {
    result = error;
  }

  return result;
};
/**
 * Returns a random string of specified length
 * (based on https://stackoverflow.com/a/1349426/293680)
 *
 * @param length
 */


var getRandomString = function getRandomString(length) {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;

  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
};
/**
 * isBlank
 * -------
 * Returns true if string is undefined or null or it's trimmed length is 0.
 * So whitespace-only strings will return true.
 *
 * Examples:
 *   isBlank(undefined)   // => true
 *   isBlank(null)        // => true
 *   isBlank('')          // => true
 *   isBlank('  ')        // => true
 *   isBlank('bob')       // => false
 *   isBlank('  bob  ')   // => false
 */


var isBlank = function isBlank(str) {
  return !str || str.trim().length === 0;
};
/**
 * isEmpty
 * -------
 * Returns true if string is undefined or null or it's length is 0
 * So whitespace-only strings will return false.
 *
 * Examples:
 *   isEmpty(undefined)   // => true
 *   isEmpty(null)        // => true
 *   isEmpty('')          // => true
 *   isEmpty('  ')        // => false
 *   isEmpty('bob')       // => false
 *   isEmpty('  bob  ')   // => false
 */


var isEmpty = function isEmpty(str) {
  return !str || str.length === 0;
};
/**
 * sanitizeString
 * --------------
 * Returns a trimmed string.
 * If trimmed string has zero length, returns null.
 *
 * Examples:
 *   sanitizeString(undefined)   // => null
 *   sanitizeString(null)        // => null
 *   sanitizeString('')          // => null
 *   sanitizeString('  ')        // => null
 *   sanitizeString('bob')       // => 'bob'
 *   sanitizeString('  bob  ')   // => 'bob'
 */


var sanitizeString = function sanitizeString(str) {
  if (!str) {
    return null;
  }

  var trimmedString = str.trim();
  return trimmedString.length > 0 ? trimmedString : null;
};

var StringUtils = {
  errorToString: errorToString,
  getRandomString: getRandomString,
  isBlank: isBlank,
  isEmpty: isEmpty,
  sanitizeString: sanitizeString
};

/**
 * Determines if two JavaScript values are equal,
 * i.e. value equality vs. reference equality.
 *
 * Use cases
 * ---------
 * - Objects stored in localStorage
 * - window.history.state
 * - query strings
 *
 * Based on: https://github.com/mjackson/value-equal
 * Fix applied: https://github.com/mjackson/value-equal/issues/10
 */
function valueEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a;
  var bType = typeof b;
  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf ? a.valueOf() : Object.prototype.valueOf.call(a);
    var bValue = b.valueOf ? b.valueOf() : Object.prototype.valueOf.call(b);
    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) return false;
    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

export { ArrayUtils, StringUtils, arrayToKeySet, compareKeyBoolValues, keySetContainsOneOf, keySetCopyValues, keySetGetOffKeys, keySetGetOnKeys, keySetToArray, keySetToKeyValue, keySetsAreEqual, keySetsMatchKeys, mergeKeySets, valueEqual };
//# sourceMappingURL=utils.esm.js.map
